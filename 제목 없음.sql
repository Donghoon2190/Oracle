CREATE user jun4 -- 다른유저 아이디 비번 생성 접속,몇가지기능 권한 부여
IDENTIFIED by "0000";
grant CONNECT,RESOURCE to jun4;

CREATE user HA4 -- 다른유저 아이디 비번 생성 접속,몇가지기능 권한 부여
IDENTIFIED by "1111";
grant CONNECT,RESOURCE to HA4;

CREATE user DAN4 -- 다른유저 아이디 비번 생성 접속,몇가지기능 권한 부여
IDENTIFIED by "0000";
grant CONNECT,RESOURCE to DAN4;


alter user donghun --DBA 수정
DEFAULT TABLESPACE users -- 테이블 저장 위치를 USERS에 넣겠다 안하면 system DBF 로 저장됨
QUOTA UNLIMITED on users; -- 사용할수 있는 범위 UNLIMITED제한없음. INTEGER M 1메가.

GRANT DBA TO donghun;

alter user hun -- DEV 수정 
DEFAULT TABLESPACE users
QUOTA UNLIMITED on users;

alter user HA4 --다른유저 수정
DEFAULT TABLESPACE users
QUOTA UNLIMITED on users;

alter user DAN4 --다른유저 수정
DEFAULT TABLESPACE users
QUOTA UNLIMITED on users;

alter user jun4 --다른유저 수정
DEFAULT TABLESPACE users
QUOTA UNLIMITED on users;

CREATE table STORES(
ST_CODE NCHAR(4),
ST_NAME NVARCHAR2(100) NOT NULL,
ST_ADDR NVARCHAR2(100)
)TABLESPACE USERS;

-- PRIVARY KEY 제약조건 추가하기
ALTER TABLE STORES
ADD CONSTRAINT ST_CODE_PK PRIMARY KEY(ST_CODE);
-- PRIVARY KEY 제약조건 삭제하기
ALTER TABLE STORES
DROP CONSTRAINT ST_CODE_PK;

INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES('I001', '훈마켓', '인천시 미추홀구 학익동');
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES(NULL, '훈마켓', '인천시 미추홀구 학익동');

--모든 테이블 검색
SELECT*FROM USER_TABLES;
--제약조건 검색
SELECT*FROM user_constraints;
--특정 테이블 검색
SELECT*FROM user_tAB_COLS WHERE TABLE_NAME = 'STORES' ;

--컬럼 삭제
ALTER TABLE STORES
DROP COLUMN ST_ADDR;

SELECT
    *
FROM user_col_privs;

--컬럼 생성
ALTER TABLE STORES
ADD ST_ADDR NVARCHAR2(100);

--컬럼 업데이트
UPDATE STORES SET ST_ADDR='인천시 미추홀구 학익동' WHERE ST_CODE= 'I001';

--컬럼 제약조건 수정하기
ALTER TABLE STORES
MODIFY ST_ADDR NOT NULL;

--테이블의 데이터 확인하기
SELECT*FROM TESTS WHERE T_QTY LIKE '_0%';

--테이블의 이름을 쉽게 호출할수 있도록 닉네임 지정하기 (SYNONYM은 만든 소유자만 사용가능)
CREATE SYNONYM ST FOR donghun.STORES;



SELECT * FROM STORES WHERE ST_ADDR NOT IN('GR');
ROLLBACK;



--닉네임 삭제하기
DROP SYNONYM ST;

--권한을 받은 사람도 닉네임을 사용할 수 있도록 PUBLIC으로 써줌
CREATE PUBLIC SYNONYM ST FOR donghun.STORES;

--hun에게 닉네임을 주며 검색 할 수 있도록 권한을 줌
GRANT SELECT ON ST TO hun;

--권한을 받은 hun이 닉네임으로 조회 가능
SELECT*FROM ST;

COMMIT WORK;

SELECT*FROM SC;

SELECT*FROM USER_TABLES;

SELECT*FROM USER_TAB_COLS WHERE TABLE_NAME='STORES';

SELECT*FROM user_constraints WHERE TABLE_NAME='STORES';

SELECT*FROM user_tab_privs_recd;

/* 특정일(특정범위)의 상품별 판매 현황 
    -- 일일 매출현황
    -- 월별 매출현황
    ---------------------------------------------------
      상품코드     상품명       주문건수       매출액
 STEP1 OT GO        GO           OT        OT * GO
    ---------------------------------------------------
*/
-- STEP2~3. ORDERDETAIL(OT)
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_ODCODE AS ORDERS,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') = '20201015';

-- STEP 4
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') = '20201015'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;

-- 특정 월의 매출현황
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMM') = '202010'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;

-- 특정 범위(일, 월)의 매출현황

SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMM') >= '202009' AND 
      TO_CHAR(OT.OT_ODCODE, 'YYYYMM') <= '202010'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;


/*WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') >= '20201001' AND
      TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') <= '20201015'*/

-- STEP 5
CREATE OR REPLACE VIEW SALESINFO
AS
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_ODCODE AS ORDERS,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

-- 특정 일의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMMDD') = '20201015'
GROUP BY GOCODE, GONAME;

-- 특정 월의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMM') = '202010'
GROUP BY GOCODE, GONAME;

-- 특정 범위(일, 월)의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMMDD') >= '20200920' AND
      TO_CHAR(ORDERS, 'YYYYMMDD') <= '20201015'
GROUP BY GOCODE, GONAME;


SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMM') >= '202009' AND
      TO_CHAR(ORDERS, 'YYYYMM') <= '202010'
GROUP BY GOCODE, GONAME;


/* 특정 상품(GOCODE)의 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
      OD OT           OT        OT * GO
    --------------------------------------
*/
SELECT  TO_CHAR(ORDERS, 'YYYYMM') AS ORDERS,
        COUNT(ORDERS) AS CNT,
        SUM(AMOUNT) AS TOTAMOUNT
FROM SALESINFO
WHERE GOCODE = '3001'
GROUP BY TO_CHAR(ORDERS, 'YYYYMM');

/* 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
      OD OT      CONUNT(OD)    SUM(OT * GO)
    --------------------------------------
*/
-- GROUPING 1
SELECT  TO_CHAR(OD_CODE, 'YYYYMM') AS SALESMONTH, 
        COUNT(OD_CODE) AS SALESCOUNT
FROM OD
GROUP BY TO_CHAR(OD_CODE, 'YYYYMM');

-- GROUPING 2
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM');

-- JOIN 
SELECT SI1.SALESMONTH, SI1.SALESCOUNT, SI2.AMOUNT
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMM') AS SALESMONTH, COUNT(OD_CODE) AS SALESCOUNT
        FROM OD
        GROUP BY TO_CHAR(OD_CODE, 'YYYYMM')) SI1
INNER JOIN 
     (SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
        FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
        GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM')) SI2
ON SI1.SALESMONTH = SI2.SALESMONTH;


/* 특정월(ODCODE)의 베스트 상품(판매갯수) 현황 
    ------------------------------------------------------
      매출월    상품코드    상품명    판매량       매출액
        OT      OT  GO      GO       OT         OT*GO
    ------------------------------------------------------
*/       
-- STEP 2~3 JOIN  --> VIEW
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_QTY AS QTY,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

-- STEP 4 GROUPING
CREATE OR REPLACE VIEW MONTHLYBEST
AS
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        SUM(OT.OT_QTY) AS QTY,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM'), OT.OT_GOCODE, GO.GO_NAME;


SELECT * 
FROM MONTHLYBEST
WHERE (SALESMONTH, QTY) IN(SELECT SALESMONTH, MAX(QTY) 
                            FROM MONTHLYBEST 
                            GROUP BY SALESMONTH);



-- GROUPING1 --> 일별 시간별 합산
SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
        COUNT(*) AS ORDERS
FROM OD
GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24');

-- GROUPING1 --> 시간대 별 평균 주문 추출
SELECT SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME, 
       TO_CHAR(ROUND(AVG(ORDERS),1), '9,990.0') AS ORDERSAVG
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
              COUNT(*) AS ORDERS
      FROM OD
      GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24'))
GROUP BY SUBSTR(SALESDAYTIME, 9,2);

-- GROUPING2 :: 일별 시간별 합산
SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAVG
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24');

-- GROUPING2 --> 시간별 평균
SELECT  SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME,
        TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990.0') AS AMOUNTAVG
FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
              SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
      FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
      GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24'))
GROUP BY SUBSTR(SALESDAYTIME, 9,2);

-- GROUPING1 JOIN GROUPING2
SELECT GR1.SALESTIME || ' TIME' AS SALESTIME,
       GR1.ORDERSAVG AS ORDERSAVG,
       GR2.AMOUNTAVG AS AMOUNTAVG
FROM (SELECT SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME, 
             ROUND(AVG(ORDERS),1) AS ORDERSAVG
      FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
                    COUNT(*) AS ORDERS
            FROM OD
            GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24'))
        GROUP BY SUBSTR(SALESDAYTIME, 9,2)) GR1
INNER JOIN 
     (SELECT  SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME,
              TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990') AS AMOUNTAVG
      FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
                    SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
            FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
            GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24'))
        GROUP BY SUBSTR(SALESDAYTIME, 9,2)) GR2
ON GR1.SALESTIME = GR2.SALESTIME;
/* 요일별 매출추이 
    --------------------------------
      요일     평균주문건수  평균매출액
    --------------------------------
*/

--요일별 평균 주문
CREATE OR REPLACE VIEW AVGORD AS
SELECT TO_CHAR(TO_DATE(SALESDAYTIME,'YYYYMMDD'),'DAY') AS SALESTIME, 
       TO_CHAR(ROUND(AVG(ORDERS),1), '9,990.0') AS ORDERSAVG
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDD') AS SALESDAYTIME, 
              COUNT(*) AS ORDERS
      FROM OD
      GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDD'))
GROUP BY TO_CHAR(TO_DATE(SALESDAYTIME,'YYYYMMDD'),'DAY');

--요일별 평균 매출
CREATE OR REPLACE VIEW AVGAMOUNT AS
SELECT  TO_CHAR(TO_DATE(SALESDAYTIME,'YYYYMMDD'),'DAY') AS SALESTIME,
        TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990') AS AMOUNTAVG
FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDD') AS SALESDAYTIME,
              SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
      FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
      GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDD'))
GROUP BY TO_CHAR(TO_DATE(SALESDAYTIME,'YYYYMMDD'),'DAY');

SELECT
A1.SALESTIME AS 요일,
ORDERSAVG AS 평균주문건수,
AMOUNTAVG AS 평균매출액
FROM AVGORD A1 INNER JOIN AVGAMOUNT A2 ON A1.SALESTIME = A2.SALESTIME;

SELECT
EM_CODE AS 사원코드,
EM_NAME AS 사원명,
COALESCE(HI_STATE,0) AS 로그인여부
FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE
;
------------------------------------------------------------
SELECT
사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGIN
FROM (SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명, HI_STATE AS 로그인여부
FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE)
WHERE 로그인여부 = 1
GROUP BY 사원코드,사원명;

SELECT
사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGOUT
FROM (SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명, HI_STATE AS 로그인여부
FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE)
WHERE 로그인여부 = -1
GROUP BY 사원코드,사원명;
/* 1. 특정 상점의 직원의 로그인과 로그아웃 횟수 기록 출력 
    ---------------------------------------------
      사원코드   사원명   로그인횟수   로그아웃 횟수
    ---------------------------------------------
*/ 
SELECT
EM_CODE AS 사원코드,EM_NAME AS 사원명,COALESCE(A3.LOGIN,0) AS LOGIN,COALESCE(A3.LOGOUT,0) AS LOGOUT

FROM(SELECT
COALESCE(A1.사원코드,A2.사원코드) AS 사원코드,COALESCE(A1.사원명,A2.사원명) AS 사원명,COALESCE(A1.LOGIN,0) AS LOGIN,COALESCE(A2.LOGOUT,0) AS LOGOUT

FROM (  SELECT 사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGIN ,STNAME AS STNAME
        FROM (  SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명,COALESCE(HI_STATE,0) AS 로그인여부,HI.HI_EMSTCODE AS STNAME
                FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE  WHERE HI_STATE = 1)
    GROUP BY 사원코드,사원명,STNAME) A1
FULL OUTER JOIN (SELECT 사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGOUT ,STNAME AS STNAME2
            FROM (  SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명, COALESCE(HI_STATE,0) AS 로그인여부 ,HI.HI_EMSTCODE AS STNAME
                    FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE   WHERE HI_STATE = -1)
            GROUP BY 사원코드,사원명,STNAME) A2 
ON A1.사원코드 = A2.사원코드) A3

RIGHT OUTER JOIN EM         ON A3.사원코드  = EM.EM_CODE

WHERE EM_STCODE = 'D001';

SELECT *
FROM HI;

/* 2. 특정 상점의 모든 직원중 로그인 횟수가 가장 많은 직원의 정보 출력 
    ----------------------------------------
      사원코드   사원명   로그인횟수   사원등급
    ----------------------------------------
*/ 
    -- 뷰 없이 문제풀기
    SELECT 사원코드,사원명,LOGIN,"LEVEL"
    FROM(SELECT 사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGIN ,STNAME AS STCODE ,"LEVEL" AS "LEVEL"
        FROM (  SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명,
                COALESCE(HI_STATE,0) AS 로그인여부,
                HI.HI_EMSTCODE AS STNAME, 
                EM_LEVEL AS "LEVEL"
                FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE)
    WHERE 로그인여부 = 1
    GROUP BY 사원코드,사원명,STNAME,"LEVEL")
    
    WHERE STCODE = 'D002' AND
    (LOGIN,STCODE) IN( SELECT MAX(LOGIN),STCODE
                        FROM( SELECT 사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGIN ,STNAME AS STCODE ,"LEVEL" AS "LEVEL"
                                FROM (   SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명,
                                         COALESCE(HI_STATE,0) AS 로그인여부,
                                         HI.HI_EMSTCODE AS STNAME, 
                                         EM_LEVEL AS "LEVEL"
                                         FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE)    WHERE 로그인여부 = 1
                                         GROUP BY 사원코드,사원명,STNAME,"LEVEL") group by STCODE);
                 
--뷰 활용하여 문제풀기

CREATE OR REPLACE VIEW LOGINMAX AS
SELECT 사원코드 AS 사원코드, 사원명 AS 사원명, COUNT(로그인여부) AS LOGIN ,STNAME AS STCODE ,"LEVEL" AS "LEVEL"
        FROM (  SELECT EM_CODE AS 사원코드, EM_NAME AS 사원명,
                COALESCE(HI_STATE,0) AS 로그인여부,
                HI.HI_EMSTCODE AS STNAME, 
                EM_LEVEL AS "LEVEL"
                FROM HI RIGHT OUTER JOIN EM ON HI.HI_EMCODE =EM.EM_CODE)
    WHERE 로그인여부 = 1
    GROUP BY 사원코드,사원명,STNAME,"LEVEL";
    
SELECT 사원코드,사원명,LOGIN,"LEVEL"
FROM LOGINMAX
WHERE STCODE = 'D002' AND 
(STCODE,LOGIN) IN (SELECT STCODE,MAX(LOGIN) AS LOGMAX FROM LOGINMAX GROUP BY STCODE);

/* 3. 특정 상점의 모든 직원을 대상으로 직원별 판매실적을 출력
    ----------------------------------------
      사원코드   사원명   주문건수    매출액
       EM        EM      OD       OT GO
    ----------------------------------------
*/ 
CREATE OR REPLACE VIEW B1 AS
SELECT
EM_CODE AS 사원코드,
EM_NAME AS 사원명,
OD_CODE AS ODCODE,
EM_STCODE AS STCODE,
OT_QTY * go.go_price AS 매출액
FROM "EM" INNER JOIN OD ON "EM".EM_CODE = OD_EMCODE
          INNER JOIN OT ON OD_CODE = OT_ODCODE
          INNER JOIN GO ON OT_GOCODE = GO_CODE;
          
SELECT
A1.사원코드,A1.사원명,주문건수,A1.매출액
FROM (  SELECT EM_CODE AS 사원코드,사원명 AS 사원명,SUM(매출액) AS 매출액,EM_STCODE AS STCODE
        FROM B1 RIGHT OUTER JOIN EM ON "EM".EM_CODE = 사원코드
        GROUP BY EM_CODE, 사원명,EM_STCODE) A1

INNER JOIN (SELECT OD_EMCODE AS 사원코드,COUNT(OD_CODE) AS 주문건수 
            FROM OD GROUP BY OD_EMCODE) A2 
    ON A1.사원코드 = A2. 사원코드

WHERE STCODE = 'D002';

/* 4. 모든 상품의 정보 출력
    --------------------------------------------
      상품코드   상품명   가격    재고     유통기한
      GO        GO      GO     SC        SC
    --------------------------------------------
*/ 
SELECT
GO_CODE AS 상품코드,
go.go_name AS 상품명,
go.go_price AS 가격,
COALESCE(sc.sc_stocks,0) AS 재고,
--COALESCE(sc.sc_expire,TO_DATE('00010101000000')) AS 유통기한
COALESCE(TO_CHAR(sc.sc_expire,'YYYYMMDDHH24MISS'),'재고가 없는 상품') AS 유통기한
FROM GO LEFT OUTER JOIN SC ON GO_CODE = SC_GOCODE;

/* 5. 4의 결과중 판매가능한 상품정보를 출력
    --------------------------------------------
      상품코드   상품명   가격    재고     유통기한
    --------------------------------------------
*/
SELECT
GO_CODE AS 상품코드,
go.go_name AS 상품명,
go.go_price AS 가격,
sc.sc_stocks AS 재고,
sc.sc_expire AS 유통기한
FROM GO LEFT OUTER JOIN SC ON GO_CODE = SC_GOCODE
WHERE  sc.sc_expire >= SYSDATE AND sc.sc_stocks >0;


SELECT
    *
FROM em;
-- 로그인 할때 입력한 아이디가 있는지 확인 있으면 1
SELECT COUNT(*) AS ISEMCODE FROM EM WHERE EM_STCODE = 'D001' AND EM_CODE = 'G002';
-- 로그인 할때 입력한 비밀번호가 맞는지 확인 맞으면 1
SELECT COUNT(*) AS ISACCESS FROM EM WHERE EM_STCODE = 'D001' AND EM_CODE = 'G002' AND EM_PWD = '0002';

-- 둘다 맞으면 로그인 => HI에 INSERT
INSERT INTO HI(HI_EMCODE,HI_ACCDATE,HI_STATE, HI_EMSTCODE) VALUES('G002',DEFAULT,1,'D001');

CREATE OR REPLACE VIEW LOGINFO AS
SELECT 
em.em_stcode STCODE,
em_code AS EMCODE,
em_name AS EMNAME,
em_level AS LEVELS ,
max(hi.hi_accdate) AS ACCESSTIME
FROM EM INNER JOIN HI ON EM.EM_STCODE = HI.HI_EMSTCODE AND EM.EM_CODE = HI.HI_EMCODE
group by em.em_stcode,em_code,em_name ,em_level ;

SELECT STCODE ,accesstime AS ACCESSTIME, EMCODE AS EMCODE, EMNAME AS EMNAME,LEVELS AS LEVELS FROM LOGINFO WHERE stcode = 'D001' AND EMCODE = 'G002';

SELECT * FROM EM ;

SELECT * FROM em;
COMMIT;
SELECT * FROM HI;

DELETE FROM EM WHERE EM_CODE ='G009';





                -----------------
CREATE OR REPLACE VIEW HISGOINFO AS 
SELECT 
TO_CHAR(OT_ODCODE,'YYYYMMDD') AS ODCODE,
GO_CODE AS GOCODE,
GO_NAME AS GONAME,
GO_PRICE AS GOPRICE,
OT_QTY AS QTY,
GO_PRICE*OT_QTY AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

SELECT * FROM HI;

CREATE OR REPLACE VIEW HISGO AS 
SELECT 
TO_CHAR(OT_ODCODE,'YYYYMM') AS ODCODE,
GO_CODE AS GOCODE,
GO_NAME AS GONAME,
GO_PRICE AS GOPRICE,
OT_QTY AS QTY,
GO_PRICE*OT_QTY AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;
                





SELECT GO_CODE AS 코드, GO_NAME AS 상품명,GO_PRICE AS 가격, MIN(SC_EXPIRE) AS 유통기한 
FROM GO INNER JOIN SC ON GO_CODE = SC_GOCODE 
WHERE GO_CODE = '1001' AND SC_EXPIRE > SYSDATE GROUP BY GO_CODE,GO_NAME,GO_PRICE;



SELECT * FROM OD;
SELECT * FROM Ot;

INSERT INTO OD(OD_CODE,OD_EMSTCODE,OD_EMCODE,OD_CMCODE,OD_STATE) 
VALUES(DEFAULT,'D001','G002','00000','P');
SELECT * FROM SC;
COMMIT;

SELECT * FROM OD;



-- OD를 입력하면 OD_CODE가 자동으로 생성되게 만들고
-- 방금 만든걸 뽑아 내기위해서 OD에서 OD_CODE가 제일 큰걸 뽑아서 ODCODE로 값을 보냄
--CREATE OR REPLACE PROCEDURE ORDMAKE
--(STCODE IN OD.OD_EMSTCODE%TYPE,
--EMCODE IN OD.OD_EMCODE%TYPE,
--CMCODE IN OD.OD_CMCODE%TYPE,
--ODSTATE IN OD.OD_STATE%TYPE,
--ODCODE OUT NVARCHAR2
--)
--IS
--
--BEGIN
--INSERT INTO OD(OD_EMSTCODE, OD_EMCODE, OD_CMCODE, OD_STATE , OD_CODE) 
--VALUES(STCODE,EMCODE,CMCODE,ODSTATE,DEFAULT);
--
--SELECT TO_CHAR(MAX(OD_CODE),'YYYYMMDDHH24MISS') INTO ODCODE FROM OD
--WHERE OD_EMSTCODE = STCODE AND OD_EMCODE = EMCODE;
--END ORDMAKE;


--drop PROCEDURE ORDMAKE;


--SET SERVEROUTPUT ON;
--
--DECLARE
--ODCODE NCHAR(14);
--
--BEGIN
--ORDMAKE('D001','G001','C0000','P',ODCODE);
--DBMS_OUTPUT.put_line(ODCODE);
--END;

ROLLBACK;
DELETE FROM OD WHERE TO_CHAR(OD_CODE,'YYYYMMDD') = '20201102';
SELECT
    *
FROM Od;

--CREATE OR REPLACE PROCEDURE INS_OT(
--  ODCODE    IN  NVARCHAR2,
--  GOCODE    IN  OT.OT_GOCODE%TYPE,
--  GOQTY     IN  OT.OT_QTY%TYPE,
--  OTSTATE   IN  OT.OT_STATE%TYPE
--)
--IS
--
--BEGIN
--    INSERT INTO OT(OT_ODCODE, OT_GOCODE, OT_QTY, OT_STATE) 
--    VALUES(TO_DATE(ODCODE, 'YYYYMMDDHH24MISS'), GOCODE, GOQTY, OTSTATE);
--END INS_OT;





--SET SERVEROUTPUT ON;
--DECLARE
--ODCODE NCHAR(14) := '20201102134829';
--GOCODE NCHAR(4) := '1001';
--QTY NUMBER:= 2;
--OTSTATE NCHAR(1):= 'P';
--BEGIN
--INS_OT(ODCODE,GOCODE,QTY,OTSTATE);
--SELECT
--ODCODE,GOCODE,QTY,OTSTATE INTO ODCODE,GOCODE,QTY,OTSTATE
--FROM OT WHERE OT_ODCODE = '20201102134829';
--DBMS_OUTPUT.PUT_LINE('ODCODE : '||ODCODE);
--DBMS_OUTPUT.PUT_LINE('GOCODE : '||GOCODE);
--DBMS_OUTPUT.PUT_LINE('QTY : '||QTY);
--DBMS_OUTPUT.PUT_LINE('STATE : '||OTSTATE);
--END;

--

CREATE TABLE STUDENT(
ST_NAME NVARCHAR2(5),
ST_AGE NUMBER(3,0)
)TABLESPACE USERS;

SELECT
    *
FROM students;



UPDATE HEEDONG.STUDENT SET ST_AGE = '24' WHERE ST_NAME='강동훈';
UPDATE HEEDONG.STUDENT SET ST_AGE = 25 WHERE ST_NAME='강동훈';

SELECT
    *
FROM user_col_privs;
UPDATE STUDENTS SET ST_AGE = '60',ST_NAME = '강동훈' WHERE ST_NAME='김김김';

CREATE TABLE INPUTT(
INPUT1 NVARCHAR2(20),
INPUT2 NVARCHAR2(20)
)TABLESPACE USERS;

COMMIT;

DELETE FROM IT ;

SELECT * FROM IT;

CREATE TABLE MEMBERT(
MB_CODE NCHAR(4),
MB_PWD NCHAR(4),
MB_NAME NVARCHAR2(5),
MB_BIRTH  NVARCHAR2(10),
MB_GENDER NCHAR(2),
MB_EMAIL NVARCHAR2(30)
)TABLESPACE USERS;

ALTER TABLE MEMBERT
MODIFY MB_BIRTH NVARCHAR2(10);

SELECT
    *
FROM MB;

DELETE FROM MB;
COMMIT;
ROLLBACK;
